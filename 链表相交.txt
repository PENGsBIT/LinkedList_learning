//判断两个单链表是否相交,如果相交返回第一个节点，否则返回null  
//如果单纯的判断是否相交，只需要看最后一个指针是否相等
public static Node isIntersect(Node head1, Node head2) {
	/*
	 * 如果两个没有环的链表相交于某个节点，那么在这个节点之后的所有节点都是两个链表所共有的
	 * 1）遍历链表1，记录其长度len1，遍历链表2，记录其长度len2
	 * 2）按尾部对齐，如果两个链表的长度不相同，让长度更长的那个链表从头节点先遍历abs(len1-en2),这样两个链表指针指向对齐的位置
	 * 3）然后两个链表齐头并进，当它们相等时，就是交集的节点 时间复杂度O(n+m)，空间复杂度O(1)
	 */
	Node target = null;
	if (head1 == null || head2 == null)
		return target;
	int lenNode1 = getListLength(head1);
	int lenNode2 = getListLength(head2);
	if (lenNode1 >= lenNode2) {
		for (int i = 0; i < lenNode1 - lenNode2; i++)
			head1 = head1.next;
	} else {
		for (int i = 0; i < lenNode2 - lenNode1; i++)
			head2 = head2.next;
	}
	while (head1 != null && head2 != null) {
		if (head1 == head2) {
			target = head1;
			break;
		} else {
			head1 = head1.next;
			head2 = head2.next;
		}
	}
	return target;
}